<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>OpenSiteEnergy Data Pipeline Monitor</title>
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, sans-serif; margin: 0; background: #ffffff; overflow: hidden; }
        #network-container { width: 100vw; height: 100vh; }
        
        #ui-overlay {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            background: rgba(255, 255, 255, 0.9); padding: 15px;
            border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 260px;
        }

        #processing-monitor {
            position: absolute; bottom: 20px; left: 0px; z-index: 10;
            background: rgba(255, 255, 255, 0.9); padding: 15px;
            border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); width: 260px;
            margin:20px; padding: 15px; 
            width:calc(100vw - 70px);

        }

        #timer-container {
            margin-bottom: 15px; padding: 12px; background: #2c3e50; 
            color: white; border-radius: 6px; text-align: center;
        }

        #property-panel {
            position: fixed; top: 0; right: 0; width: 500px; height: 100%; 
            background: white; border-left: 1px solid #ccc; padding: 20px; 
            overflow-y: auto; z-index: 1000; display: none; box-shadow: -5px 0 15px rgba(0,0,0,0.05);
        }
        
        /* --- CONSOLE STYLES --- */
        #console-panel {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 400px;
            background: #121212; color: #d4d4d4; font-family: 'Consolas', monospace;
            padding: 10px; overflow-y: auto; display: none; z-index: 1500;
            border-top: 3px solid #333; box-sizing: border-box;
        }
        .log-line { font-size: 0.8rem; margin-bottom: 2px; border-bottom: 1px solid #1e1e1e; white-space: pre-wrap; }
        .log-ts { color: #858585; margin-right: 10px; }
        .btn-console { background: #34495e !important; color: white !important; border: none !important; }

        .legend-item { display: flex; align-items: center; margin-bottom: 5px; font-size: 0.85rem; }
        .dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 10px; border: 1px solid #999; }
        .count-val { font-weight: bold; margin-left: 4px; color: #2c3e50; }

        pre { background: #f8f8f8; padding: 10px; border-radius: 4px; font-size: 0.75rem; white-space: pre-wrap; }
        button { cursor: pointer; padding: 8px; border-radius: 4px; border: 1px solid #ccc; background: #fff; width: 100%; margin-top: 10px; }
        button:hover { background: #f0f0f0; }

        /* TOOLTIP: Plenty of space, standard legible font */
        div.vis-network div.vis-tooltip {
            background-color: #2c3e50;
            color: #ffffff;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            font-size: 14px;
            padding: 0; /* Let the internal div handle padding for the colored border */
            border-radius: 6px;
            border: 1px solid #1a252f;
            box-shadow: 0 6px 15px rgba(0,0,0,0.4);
        }

        .tooltip-inner {
            padding: 10px;
            border-left: 5px solid; /* Color is set inline in JS */
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <h2 style="margin:0 0 10px 0; font-size: 1.1rem;">Data Processing Monitor</h2>
        
        <div id="timer-container">
            <div style="font-size: 0.65rem; text-transform: uppercase; opacity: 0.7; letter-spacing: 1px;">Elapsed Time</div>
            <div id="timer-val" style="font-size: 1.6rem; font-weight: bold; font-family: 'Courier New', monospace;">00:00</div>
            <div id="total-time" style="font-size: 0.75rem; color: #18bc9c; margin-top: 4px; display: none; font-weight: bold;">Final: <span></span></div>
        </div>

        <div id="last-sync" style="font-size: 0.7rem; color: #888; margin-bottom: 12px;">Waiting for data...</div>
        
        <div class="legend">
            <div class="legend-item"><span class="dot" style="background: #0b7a39;"></span> Processed <span id="count-processed" class="count-val">(0)</span></div>
            <div class="legend-item"><span class="dot" style="background: #FFA500;"></span> Processing <span id="count-processing" class="count-val">(0)</span></div>
            <div class="legend-item"><span class="dot" style="background: #FEE245;"></span> Unprocessed <span id="count-unprocessed" class="count-val">(0)</span></div>
            <div class="legend-item"><span class="dot" style="background: #ec0a0a;"></span> Failed <span id="count-failed" class="count-val">(0)</span></div>
        </div>
        <button onclick="network.fit()">Center View</button>
        <button class="btn-console" onclick="toggleConsole()">Toggle Console Logs</button>

    </div>

    <div id="console-panel">
        <div id="log-content"></div>
    </div>

    <div id="processing-monitor">
        <h4 style="margin-top: 0; color: #3498db;">Active Processes</h4>
        <div id="active-node-list">
            <p style="color: #888; font-style: italic;">No active nodes...</p>
        </div>
    </div>

    <div id="property-panel">
        <button style="width: auto; float: right;" onclick="document.getElementById('property-panel').style.display='none'">Ã—</button>
        <h3 id="prop-title">Node Metadata</h3>
        <pre id="prop-content"></pre>
    </div>

    <div id="network-container"></div>

    <script type="text/javascript">
        const nodes = new vis.DataSet([]);
        const edges = new vis.DataSet([]);
        const container = document.getElementById('network-container');

        const statusColors = {
            "processed": "#0b7a39",
            "processing": "#FFA500",
            "unprocessed": "#FEE245",
            "failed": "#ec0a0a"
        };

        let colorStep = 0;
        let serverStartTime = null;
        let finalDuration = null;
        let lastLogIndex = 0;

        function toggleConsole() {
            const panel = document.getElementById('console-panel');
            const isHidden = window.getComputedStyle(panel).display === 'none';
            panel.style.display = isHidden ? 'block' : 'none';
            if (isHidden) {
                setTimeout(() => { panel.scrollTop = panel.scrollHeight; }, 10);
            }
        }

        function lerpColor(color1, color2, factor) {
            const r1 = parseInt(color1.substring(1, 3), 16), g1 = parseInt(color1.substring(3, 5), 16), b1 = parseInt(color1.substring(5, 7), 16);
            const r2 = parseInt(color2.substring(1, 3), 16), g2 = parseInt(color2.substring(3, 5), 16), b2 = parseInt(color2.substring(5, 7), 16);
            const r = Math.round(r1 + factor * (r2 - r1)), g = Math.round(g1 + factor * (g2 - g1)), b = Math.round(b1 + factor * (b2 - b1));
            return `rgb(${r}, ${g}, ${b})`;
        }

        function pulseProcessingNodes() {
            colorStep += 0.5;
            const factor = (Math.sin(colorStep) + 1) / 2; 
            const currentColor = lerpColor("#FFA500", "#FFFFFF", factor);
            const processingNodes = nodes.get({ filter: (item) => item.raw && item.raw.status === 'processing' });
            const updates = processingNodes.map(node => ({ id: node.id, color: { background: currentColor, border: "#BBB" } }));
            if (updates.length > 0) nodes.update(updates);
        }

        function updateGlobalTimer() {
            if (!serverStartTime) return;
            const allNodes = nodes.get();
            const isStillWorking = allNodes.some(n => n.raw.status === 'processing' || n.raw.status === 'unprocessed');
            let displaySeconds = finalDuration ? finalDuration : Math.max(0, Math.floor((Date.now() - serverStartTime) / 1000));
            const hrs = Math.floor(displaySeconds / 3600), mins = Math.floor((displaySeconds % 3600) / 60), secs = displaySeconds % 60;
            const formatted = (hrs > 0 ? hrs + ":" : "") + mins.toString().padStart(2, '0') + ":" + secs.toString().padStart(2, '0');
            const timerElement = document.getElementById('timer-val');
            timerElement.innerText = formatted;
            if (!isStillWorking && allNodes.length > 0 && !finalDuration) {
                finalDuration = displaySeconds;
                document.getElementById('total-time').style.display = 'block';
                document.getElementById('total-time').querySelector('span').innerText = formatted;
                timerElement.style.color = "#18bc9c";
            }
        }

        function parsePipelineData(node, nodesArray, edgesArray) {
            const color = statusColors[node.status] || "#efefef";
            
            // Create an HTML title with a colored border
            const titleElement = document.createElement("div");
            titleElement.className = "tooltip-inner";
            titleElement.style.borderLeftColor = color;

            let durationText = "";
            if (node.log && Array.isArray(node.log)) {
                // Find the dict that has the 'duration' key
                const durationEntry = node.log.find(entry => "duration" in entry);
                if (durationEntry) {
                    const cleanDuration = durationEntry.duration.split('.')[0];
                    durationText = `<div style="margin-top: 8px; border-top: 1px solid #444; pt-5px;">
                                        <span style="color: #18bc9c; font-weight: bold;">Duration:</span> ${cleanDuration}
                                    </div>`;
                }
            }

            titleElement.innerHTML = `
                <div style="font-weight:bold; margin-bottom: 5px;">${node.title || node.name}</div>
                <div style="font-size: 0.8rem; opacity: 0.9;">
                    Type: ${node.node_type}<br>
                    Status: <span style="color:${color}; font-weight:bold;">${node.status.toUpperCase()}</span>
                    ${durationText}
                </div>
            `;

            nodesArray.push({
                id: node.urn,
                label: node.title.replaceAll(' - ', '\n'),
                title: titleElement,
                color: { background: color, border: "#BBB" },
                font: { size: 80, face: 'Arial Narrow' },
                raw: node 
            });

            if (node.children) {
                node.children.forEach(child => {
                    edgesArray.push({ from: node.urn, to: child.urn, arrows: 'to', color: { color: '#AAA' }, scaleFactor: 20});
                    parsePipelineData(child, nodesArray, edgesArray);
                });
            }
        }

        function getActiveNodeTimers(nodes) {
            const now = new Date();

            return nodes
                .filter(node => node.raw.status === 'processing')
                .map(node => {
                    const startEntry = [...node.raw.log].reverse().find(entry => {
                        return entry.hasOwnProperty('started');
                    });
                    let elapsedStr = "Starting...";
                    let seconds = 0;

                    if (startEntry) {
                        const timestampValue = startEntry.started; 
                        const startTime = new Date(timestampValue);
                        const diff = Math.floor((now - startTime) / 1000); 
                        const h = Math.floor(diff / 3600);
                        const m = Math.floor((diff % 3600) / 60);
                        const s = diff % 60;
                        
                        // Format as HH:MM:SS
                        elapsedStr = [h, m, s].map(v => v.toString().padStart(2, '0')).join(':');
                        seconds = diff;
                    }

                    return {
                        id: node.raw.urn,
                        name: node.raw.name,
                        elapsed: elapsedStr,
                        rawSeconds: seconds
                    };
                })
                .sort((a, b) => b.rawSeconds - a.rawSeconds); // Sort longest running first
        }

        function updateMonitorUI(nodes) {
            const container = document.getElementById('active-node-list');
            const activeNodes = getActiveNodeTimers(nodes);

            if (activeNodes.length === 0) {
                container.innerHTML = '<p style="color: #888; font-style: italic;">No active nodes...</p>';
                return;
            }

            container.innerHTML = activeNodes.map(node => `
                <div style="display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid #444; padding: 8px 0;">
                    <div>
                        <span style="font-weight: bold;">${node.name}</span>
                        <br/>
                        <small style="color: #aaa;">ID: ${node.id}</small>
                    </div>
                    <div style="font-family: monospace; color: #2ecc71; font-size: 1.2em;">
                        ${node.elapsed}
                    </div>
                </div>
            `).join('');
        }

        async function updateGraph() {
            try {
                const response = await fetch(`/nodes?last_index=${lastLogIndex}`);
                const rawData = await response.json();
                
                if (rawData.process_started) serverStartTime = new Date(rawData.process_started).getTime();

                if (rawData.logs && rawData.logs.length > 0) {
                    const logContent = document.getElementById('log-content');
                    const panel = document.getElementById('console-panel');
                    rawData.logs.forEach(log => {
                        const line = document.createElement('div');
                        line.className = 'log-line';
                        let msgColor = "#d4d4d4";
                        if (log.msg.includes("OpenSiteDownloader")) msgColor = "#d88bf0";
                        if (log.msg.includes("OpenSiteSpatial")) msgColor = "#ce9178";
                        if (log.msg.includes("[amalgamate]")) msgColor = "#569cd6";
                        if (log.msg.includes("[postprocess]")) msgColor = "#2d9c33";
                        if (log.msg.includes("OpenSiteOutput")) msgColor = "#6078e0";
                        if (log.msg.includes("OpenSitePostGIS")) msgColor = "#f5b547";
                        if (log.msg.includes("ERROR")) msgColor = "#de0d0d";

                        line.innerHTML = `<span class="log-ts">${log.time}</span><span style="color:${msgColor}">${log.msg}</span>`;
                        logContent.appendChild(line);
                    });
                    lastLogIndex = rawData.next_index;
                    if (window.getComputedStyle(panel).display !== 'none') panel.scrollTop = panel.scrollHeight;
                }

                const tempNodes = [], tempEdges = [];
                if (rawData.children && rawData.children.length > 0) {
                    rawData.children.forEach(branch => parsePipelineData(branch, tempNodes, tempEdges));
                } else if (rawData.name) {
                    parsePipelineData(rawData, tempNodes, tempEdges);
                }

                nodes.update(tempNodes);
                edges.update(tempEdges);

                const allNodes = nodes.get();

                const counts = { processed: 0, processing: 0, unprocessed: 0, failed: 0 };
                allNodes.forEach(n => { if(counts.hasOwnProperty(n.raw.status)) counts[n.raw.status]++; });
                updateMonitorUI(allNodes);
                
                document.getElementById('count-processed').innerText = `(${counts.processed})`;
                document.getElementById('count-processing').innerText = `(${counts.processing})`;
                document.getElementById('count-unprocessed').innerText = `(${counts.unprocessed})`;
                document.getElementById('count-failed').innerText = `(${counts.failed})`;

                document.getElementById('last-sync').innerText = "Last Sync: " + new Date().toLocaleTimeString();
            } catch (error) { console.error("API Error:", error); }
        }

        const options = {
            nodes: { shape: 'dot', size: 300, font: { 
                    multi: true
                },
                widthConstraint: {
                    maximum: 900
                } 
            },
            edges: { smooth: false, width: 2, color: { color: '#D3D3D3', highlight: '#848484', hover: '#848484' }, arrows: { to: { enabled: true, scaleFactor: 20 } } },
            layout: { hierarchical: { enabled: true, direction: "UD", sortMethod: "directed", levelSeparation: 3000, nodeSpacing: 900, treeSpacing: 800 } },
            physics: { enabled: false },
            interaction: { 
                dragNodes: true, 
                hover: true,
                tooltipDelay: 100 // Makes it feel snappier
            }
        };

        const network = new vis.Network(container, { nodes, edges }, options);
        network.once("afterDrawing", () => setTimeout(() => network.setOptions({ layout: { hierarchical: false } }), 1000));

        network.on("click", (params) => {
            if (params.nodes.length > 0) {
                const node = nodes.get(params.nodes[0]);
                const metadata = { ...node.raw }; delete metadata.children;
                document.getElementById('property-panel').style.display = 'block';
                document.getElementById('prop-title').innerText = node.label;
                document.getElementById('prop-content').innerText = JSON.stringify(metadata, null, 2);
            }
        });

        updateGraph().then(() => setTimeout(() => network.fit(), 500));
        setInterval(updateGraph, 5000);
        setInterval(pulseProcessingNodes, 500);
        setInterval(updateGlobalTimer, 1000);
    </script>
</body>
</html>